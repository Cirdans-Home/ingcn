
<!DOCTYPE html>

<html lang="it">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>L’Aritmetica di Precisione Finita &#8212; Calcolo Numerico - Note ed Esercitazioni di Laboratorio</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" href="_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="_static/proof.css" />
    <link rel="stylesheet" type="text/css" href="_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/jquery.js"></script>
    <script src="_static/underscore.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/clipboard.min.js"></script>
    <script src="_static/copybutton.js"></script>
    <script src="_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="_static/togglebutton.js"></script>
    <script src="_static/translations.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="_static/sphinx-thebe.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Indice" href="genindex.html" />
    <link rel="search" title="Cerca" href="search.html" />
    <link rel="next" title="Laboratorio 2 : L’Aritmetica di Precisione Finita" href="laboratorio2.html" />
    <link rel="prev" title="Laboratorio 1 : Introduzione a MATLAB" href="laboratorio1.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="it">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Calcolo Numerico - Note ed Esercitazioni di Laboratorio</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="intro.html">
                    Calcolo Numerico - Appunti ed esercitazioni di Laboratorio
                </a>
            </li>
        </ul>
        <ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio1.html">
   Laboratorio 1 : Introduzione a MATLAB
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   L’Aritmetica di Precisione Finita
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio2.html">
   Laboratorio 2 : L’Aritmetica di Precisione Finita
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="eqnonlineari.html">
   Risoluzione numerica di equazioni nonlineari
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio3.html">
   Laboratorio 3 : Il Metodo di Bisezione
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio4.html">
   Laboratorio 4 : Il Metodo di Newton
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio5.html">
   Laboratorio 5 : Soluzione di Sistemi Triangolari
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio6.html">
   Laboratorio 6 : L’Eliminazione di Gauss il Metodo LU
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio7.html">
   Laboratorio 7 : Metodi Stazionari per Sistemi Lineari
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio8.html">
   Laboratorio 8 : Metodi di Quadratura
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio9.html">
   Laboratorio 9 : Metodi per la Soluzione di ODE
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="laboratorio10.html">
   Laboratorio 10 : Metodi di tipo Runge-Kutta
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/Cirdans-Home/ingcn"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/Cirdans-Home/ingcn/issues/new?title=Issue%20on%20page%20%2Faritmeticadimacchina.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="_sources/aritmeticadimacchina.md"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.md</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   L’Aritmetica di Precisione Finita
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#numeri-di-macchina">
   Numeri di macchina
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#numeri-interi">
     Numeri interi
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#numeri-floating-point">
   Numeri floating-point
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#errori-di-troncamento-e-arrotondamento">
   Errori di troncamento e arrotondamento
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#aritmetica-di-macchina">
   Aritmetica di macchina
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#valutazione-di-una-funzione-analisi-dell-errore">
   Valutazione di una funzione: analisi dell’errore
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#condizionamento-delle-operazioni-di-macchina">
     Condizionamento delle operazioni di macchina
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#referenze">
   Referenze
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>L’Aritmetica di Precisione Finita</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   L’Aritmetica di Precisione Finita
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#numeri-di-macchina">
   Numeri di macchina
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#numeri-interi">
     Numeri interi
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#numeri-floating-point">
   Numeri floating-point
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#errori-di-troncamento-e-arrotondamento">
   Errori di troncamento e arrotondamento
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#aritmetica-di-macchina">
   Aritmetica di macchina
  </a>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#valutazione-di-una-funzione-analisi-dell-errore">
   Valutazione di una funzione: analisi dell’errore
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#condizionamento-delle-operazioni-di-macchina">
     Condizionamento delle operazioni di macchina
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#referenze">
   Referenze
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="l-aritmetica-di-precisione-finita">
<h1>L’Aritmetica di Precisione Finita<a class="headerlink" href="#l-aritmetica-di-precisione-finita" title="Link a questa intestazione">#</a></h1>
<p>Lo studio matematico di un fenomeno naturale passa generalmente per una
prima fase di <em>modellizzazione</em>, seguita poi dalla risoluzione del
problema matematico. Spesso il problema matematico ha caratteristiche
tali per cui un approccio analitico non è appropriato e si preferisce
invece ricorrere a tecniche numeriche. In questo corso prendiamo in
considerazione alcuni problemi matematici fondamentali (soluzione di
sistemi lineari, soluzione di equazioni nonlineari, interpolazione,
calcolo di un integrale definito, risoluzione di un’equazione
differenziale) e studiamo degli algoritmi numerici che permettano di
risolvere tali problemi.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="numeri-di-macchina">
<h1>Numeri di macchina<a class="headerlink" href="#numeri-di-macchina" title="Link a questa intestazione">#</a></h1>
<p>Richiamiamo innanzi tutto la nozione di numeri di macchina, ovvero come
i numeri sono rappresentati in un calcolatore. Distinguiamo due insiemi
numerici: i <em>numeri interi</em> e i <em>numeri floating-point</em> (che sono
approssimazioni dei numeri reali).</p>
<section id="numeri-interi">
<h2>Numeri interi<a class="headerlink" href="#numeri-interi" title="Link a questa intestazione">#</a></h2>
<p>Per i numeri interi, la rappresentazione di macchina con <span class="math notranslate nohighlight">\(s+1\)</span> bit è del
tipo</p>
<div class="math notranslate nohighlight">
\[\underbrace{\alpha_0}_\textrm{segno}\,\underbrace{\alpha_1\,\alpha_2\,\dots\alpha_s}_{\textrm{cifre}}\,{\rm in}\,{\rm base}\, b\]</div>
<p>dove tipicamente si prende <span class="math notranslate nohighlight">\(b=2\)</span>. Abbiamo quindi un bit che rappresenta
il segno, seguito da <span class="math notranslate nohighlight">\(s\)</span> bit che rappresentano le cifre binarie del
numero. Il numero <span class="math notranslate nohighlight">\(n\)</span> ottenuto in questo modo è</p>
<div class="math notranslate nohighlight">
\[\begin{split}n=\left\{\begin{array}{cc}
\sum_{i=1}^s\alpha_i b^{s-i} &amp; {\rm se}\,\,{\rm segno}\,\,+\\
\sum_{i=1}^s\alpha_i b^{s-i}-b^s &amp; {\rm se}\,\,{\rm segno}\,\,-
\end{array}\right.\end{split}\]</div>
<div class="tip admonition">
<p class="admonition-title">Esempio</p>
<p>Sia <span class="math notranslate nohighlight">\(b=2\)</span>, <span class="math notranslate nohighlight">\(s=3\)</span>. Quali numeri interi posso rappresentare?</p>
<p>Se il segno è positivo, posso formare i numeri seguenti:</p>
<table class="colwidths-auto table">
<thead>
<tr class="row-odd"><th class="head"><p>binario</p></th>
<th class="head"><p>001</p></th>
<th class="head"><p>010</p></th>
<th class="head"><p>011</p></th>
<th class="head"><p>100</p></th>
<th class="head"><p>101</p></th>
<th class="head"><p>110</p></th>
<th class="head"><p>111</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>decimale</p></td>
<td><p>1</p></td>
<td><p>2</p></td>
<td><p>3</p></td>
<td><p>4</p></td>
<td><p>5</p></td>
<td><p>6</p></td>
<td><p>7</p></td>
</tr>
</tbody>
</table>
<p>mentre <span class="math notranslate nohighlight">\(000\)</span> corrisponde allo zero. Se il segno è negativo posso formare
i numeri interi da <span class="math notranslate nohighlight">\(-8\)</span> a <span class="math notranslate nohighlight">\(-1\)</span>. Quindi l’insieme rappresentabile con
<span class="math notranslate nohighlight">\(b=2\)</span> e <span class="math notranslate nohighlight">\(s=3\)</span> è</p>
<div class="math notranslate nohighlight">
\[
\{-8,-7,-6,-5,-4,-3,-2,-1,0, 1, 2, 3, 4, 5, 6, 7\}.\]</div>
</div>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="numeri-floating-point">
<h1>Numeri floating-point<a class="headerlink" href="#numeri-floating-point" title="Link a questa intestazione">#</a></h1>
<p>Richiamiamo innanzi tutto il teorema di rappresentazione in base, che ci
servirà per definire i numeri floating-point. Noi siamo abituati a
scrivere i numeri reali con notazione posizionale in base 10, per
esempio</p>
<div class="math notranslate nohighlight">
\[
123,45=1\times 10^2+2\times 10^1+3\times 10^0 + 4\times 10^{-1}+5\times 10^{-2}\]</div>
<p>e spesso troviamo comodo usare una «notazione scientifica» del tipo</p>
<div class="math notranslate nohighlight">
\[
123,45=0,12345\times 10^3.\]</div>
<p>Queste considerazioni si riassumono (e
generalizzano ad una base qualsiasi) come segue.</p>
<div class="proof theorem admonition" id="theorem-0">
<p class="admonition-title"><span class="caption-number">Theorem 1 </span></p>
<section class="theorem-content" id="proof-content">
<p>Sia <span class="math notranslate nohighlight">\(b\geq 2\)</span>
un numero intero fissato (<em>base</em>). Allora per ogni
<span class="math notranslate nohighlight">\(x\in\mathbb{R}\setminus\{0\}\)</span> esistono</p>
<ul class="simple">
<li><p>un numero intero <span class="math notranslate nohighlight">\(\eta\)</span> <em>(esponente)</em></p></li>
<li><p>numeri interi <span class="math notranslate nohighlight">\(\alpha_1,\alpha_2,\ldots\)</span> <em>(cifre)</em> compresi fra <span class="math notranslate nohighlight">\(0\)</span>
e <span class="math notranslate nohighlight">\(b-1\)</span>, con <span class="math notranslate nohighlight">\(\alpha_1\neq 0\)</span>, non definitivamente uguali a <span class="math notranslate nohighlight">\(b-1\)</span>,</p></li>
</ul>
<p>tali che</p>
<div class="math notranslate nohighlight">
\[
x={\rm segno}(x)\,\, b^{\eta}\,\sum_{i=1}^{\infty}\alpha_i b^{-i}.\]</div>
</section>
</div><p>La rappresentazione data in questo teorema si dice <em>normalizzata</em>: la
condizione <span class="math notranslate nohighlight">\(\alpha_1\neq 0\)</span> serve ad assicurare l’unicità della
rappresentazione. Allo stesso tempo, però, la normalizzazione impedisce
di rappresentare <span class="math notranslate nohighlight">\(x=0\)</span>.</p>
<p>Nella pratica ci interessano soprattutto i casi <span class="math notranslate nohighlight">\(b=10\)</span> (la consueta base
decimale) e <span class="math notranslate nohighlight">\(b=2\)</span> (poiché generalmente un computer usa campi di memoria
– <em>bit</em> – con due stati possibili).</p>
<p>Nel teorema di rappresentazione in base, l’esponente e il numero di
cifre variano in un insieme infinito. In un calcolatore, però, possiamo
allocare solo una quantità finita di memoria per la rappresentazione di
un numero, quindi dobbiamo imporre dei limiti su esponente e numero di
cifre.</p>
<div class="proof definition admonition" id="definition-1">
<p class="admonition-title"><span class="caption-number">Definition 1 </span></p>
<section class="definition-content" id="proof-content">
<p>Siano fissati i seguenti numeri interi:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(b\geq 2\)</span> (base),</p></li>
<li><p><span class="math notranslate nohighlight">\(m,M\geq 1\)</span> (limiti sull’esponente),</p></li>
<li><p><span class="math notranslate nohighlight">\(t\geq 1\)</span> (numero di cifre).</p></li>
</ul>
<p>Si definisce l’insieme dei numeri di macchina floating-point</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}_{b,t,m,M}=\left\{
x={\rm segno}(x)\,\, b^{\eta}\,\sum_{i=1}^{t}\alpha_i b^{-i}
\right\}\cup\{0\},\]</div>
<p>dove gli <span class="math notranslate nohighlight">\(\alpha_i\)</span> sono interi tali che
<span class="math notranslate nohighlight">\(0\leq \alpha_i\leq b-1\)</span> e <span class="math notranslate nohighlight">\(\alpha_1\neq 0\)</span>.</p>
</section>
</div><div class="admonition-esempio admonition">
<p class="admonition-title">Esempio</p>
<p>Osserviamo che <span class="math notranslate nohighlight">\(\mathcal{F}_{b,t,m,M}\)</span> è un insieme finito, e che la
distribuzione dei suoi elementi sulla retta reale non è uniforme.</p>
<p>Costruiamo <span class="math notranslate nohighlight">\(\mathcal{F}_{b,t,m,M}\)</span> per <span class="math notranslate nohighlight">\(b=2\)</span>, <span class="math notranslate nohighlight">\(t=3\)</span>, <span class="math notranslate nohighlight">\(M=m=1\)</span>.</p>
<p>Consideriamo dapprima il caso con segno positivo. Per <span class="math notranslate nohighlight">\(\eta=0\)</span>
otteniamo, in notazione binaria, i numeri</p>
<div class="math notranslate nohighlight">
\[
(0,100)_2\qquad (0,101)_2\qquad (0,110)_2\qquad (0,111)_2,\]</div>
<p>cioè,
nell’ordine, <span class="math notranslate nohighlight">\(1/2\)</span>, <span class="math notranslate nohighlight">\(5/8\)</span>, <span class="math notranslate nohighlight">\(3/4\)</span> e <span class="math notranslate nohighlight">\(7/8\)</span>. Per <span class="math notranslate nohighlight">\(\eta=1\)</span> si ottiene <span class="math notranslate nohighlight">\(1\)</span>,
<span class="math notranslate nohighlight">\(5/4\)</span>, <span class="math notranslate nohighlight">\(3/2\)</span> e <span class="math notranslate nohighlight">\(7/4\)</span>, e per <span class="math notranslate nohighlight">\(\eta=-1\)</span> si ottiene <span class="math notranslate nohighlight">\(1/4\)</span>, <span class="math notranslate nohighlight">\(5/16\)</span>, <span class="math notranslate nohighlight">\(3/8\)</span> e
<span class="math notranslate nohighlight">\(7/16\)</span>. Se il segno è negativo si ottengono gli opposti dei numeri
elencati. Graficamente l’insieme <span class="math notranslate nohighlight">\(\mathcal{F}_{2,3,1,1}\)</span> si rappresenta
come</p>
<a class="reference internal image-reference" href="_images/figurafloatingpoints.png"><img alt="_images/figurafloatingpoints.png" class="align-center" src="_images/figurafloatingpoints.png" style="width: 80%;" /></a>
<p>dove i numeri con esponente <span class="math notranslate nohighlight">\(-1\)</span> sono indicati in blu, i numeri con
esponente <span class="math notranslate nohighlight">\(0\)</span> sono indicati in rosso e i numeri con esponente <span class="math notranslate nohighlight">\(1\)</span> sono
indicati in verde. Osserviamo l’assenza di numeri di macchina
nell’intervallo <span class="math notranslate nohighlight">\((-1/4,1/4)\)</span>, con l’eccezione di <span class="math notranslate nohighlight">\(0\)</span>.</p>
<p>Il numero positivo più piccolo in <span class="math notranslate nohighlight">\(\mathcal{F}_{b,t,m,M}\)</span> è
<span class="math notranslate nohighlight">\(r=b^{-m-1}\)</span>; lo si ottiene per esponente <span class="math notranslate nohighlight">\(-m\)</span> e cifre
<span class="math notranslate nohighlight">\(\alpha_1=1, \alpha_2=\ldots =\alpha_t=0\)</span>.</p>
</div>
<p>Il numero positivo più grande <span class="math notranslate nohighlight">\(R\)</span> si ottiene invece scegliendo esponente
<span class="math notranslate nohighlight">\(M\)</span> e cifre tutte uguali a <span class="math notranslate nohighlight">\(b-1\)</span>. Si ha quindi <span class="math notranslate nohighlight">\(R=b^M(1-b^{-t})\)</span>. Vale
l’inclusione</p>
<div class="math notranslate nohighlight">
\[
\mathcal{F}_{b,t,m,M}\subset [-R,-r]\cup \{0\} \cup [r,R].\]</div>
<p>In formato «double» (doppia precisione), nel quale si usano <span class="math notranslate nohighlight">\(64\)</span> bit per
rappresentare ciascun numero: 1 bit per il segno, 11 bit per l’esponente
e 52 bit per la mantissa (cioè il fattore
<span class="math notranslate nohighlight">\(\sum_{i=1}^{t}\alpha_i b^{-i}\)</span>). Osserviamo che, in base <span class="math notranslate nohighlight">\(2\)</span>, la prima
cifra <span class="math notranslate nohighlight">\(\alpha_1\)</span> deve essere necessariamente 1, perciò non è necessario
rappresentarla esplicitamente.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="errori-di-troncamento-e-arrotondamento">
<h1>Errori di troncamento e arrotondamento<a class="headerlink" href="#errori-di-troncamento-e-arrotondamento" title="Link a questa intestazione">#</a></h1>
<p>Supponiamo di aver fissato <span class="math notranslate nohighlight">\(b\)</span>, <span class="math notranslate nohighlight">\(t\)</span>, <span class="math notranslate nohighlight">\(m\)</span> e <span class="math notranslate nohighlight">\(M\)</span>. Nel seguito poniamo per
semplicità di notazione <span class="math notranslate nohighlight">\(\mathcal{F}=\mathcal{F}_{b,t,m,M}\)</span>.</p>
<p>Dato <span class="math notranslate nohighlight">\(x\in\mathbb{R}\)</span>, vogliamo approssimare <span class="math notranslate nohighlight">\(x\)</span> con un opportuno
<span class="math notranslate nohighlight">\(\tilde{x}\in \mathcal{F}\)</span>.</p>
<ul class="simple">
<li><p>Se <span class="math notranslate nohighlight">\(|x|&gt;R\)</span>, si ha il fenomeno dell”<em>overflow</em>.</p></li>
<li><p>Se <span class="math notranslate nohighlight">\(|x|&lt;r\)</span>, <span class="math notranslate nohighlight">\(x\neq 0\)</span>, si ha <em>underflow</em>. In questo caso il numero
viene generalmente posto a zero. Una parziale soluzione al problema
dell’underflow si ha denormalizzando la mantissa, cioè autorizzando
una scelta di <span class="math notranslate nohighlight">\(\alpha_1,\ldots,\alpha_t\)</span> con <span class="math notranslate nohighlight">\(\alpha_1=0\)</span>.</p></li>
<li><p>Se <span class="math notranslate nohighlight">\(x\in \mathcal{F}\)</span>, si pone <span class="math notranslate nohighlight">\(\tilde{x}=x\)</span>.</p></li>
</ul>
<p>Resta da discutere il caso <span class="math notranslate nohighlight">\(r&lt;|x|&lt;R\)</span> con <span class="math notranslate nohighlight">\(x\notin \mathcal{F}\)</span>.
Supponiamo per semplicità <span class="math notranslate nohighlight">\(x&gt;0\)</span>; il caso negativo è ovviamente analogo.
Sia</p>
<div class="math notranslate nohighlight">
\[
x=b^{\eta}\,\sum_{i=1}^{\infty}\alpha_i b^{-i}\]</div>
<p>la
rappresentazione in base di <span class="math notranslate nohighlight">\(x\)</span>. Abbiamo allora due possibilità per
scegliere <span class="math notranslate nohighlight">\(\tilde{x}\)</span>:</p>
<ul class="simple">
<li><p>troncamento:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\tilde{x}={\rm trn}(x):=b^{\eta}\,\sum_{i=1}^{t}\alpha_i b^{-i},\]</div>
<ul class="simple">
<li><p>arrotondamento:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[
\tilde{x}={\rm arr}(x):=b^{\eta}\,{\rm trn}\left(\sum_{i=1}^{t+1}\alpha_i b^{-i}+\frac12 b^{-t}\right).\]</div>
<p>In altre parole, sia <span class="math notranslate nohighlight">\(r_1={\rm trn}(x)\)</span> e <span class="math notranslate nohighlight">\(r_2=r_1+b^{\eta-t}\)</span>.
Osserviamo che <span class="math notranslate nohighlight">\(r_1\)</span> e <span class="math notranslate nohighlight">\(r_2\)</span> sono numeri di macchina consecutivi tali
che <span class="math notranslate nohighlight">\(r_1&lt;x&lt;r_2\)</span>. Allora si ha</p>
<div class="math notranslate nohighlight">
\[\begin{split}
{\rm arr}(x)=\left\{\begin{array}{ll}
r_1 &amp; {\rm se}\,\, x&lt;\frac{r_1+r_2}{2},\\
r_2 &amp; {\rm se}\,\, x\geq\frac{r_1+r_2}{2}.\end{array}\right.\end{split}\]</div>
<p>L”<em>errore
di rappresentazione</em> che si commette arrotondando o troncando <span class="math notranslate nohighlight">\(x\)</span> è:</p>
<ul class="simple">
<li><p>per il troncamento</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;&amp; \left|x-{\rm trn}(x)\right|\leq b^{\eta-t}\qquad {\rm (errore}\,\,{\rm assoluto),}\\
    &amp;&amp; \left|\frac{x-{\rm trn}(x)}{x}\right|\leq b^{1-t}\qquad {\rm (errore}\,\,{\rm relativo),}\end{aligned}\end{split}\]</div>
<ul class="simple">
<li><p>per l’arrotondamento</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
    &amp;&amp; \left|x-{\rm arr}(x)\right|\leq \frac12 b^{\eta-t}\qquad {\rm (errore}\,\,{\rm assoluto),}\\
    &amp;&amp; \left|\frac{x-{\rm arr}(x)}{x}\right|\leq \frac12 b^{1-t}\qquad {\rm (errore}\,\,{\rm relativo).}\end{aligned}\end{split}\]</div>
<p>Gli errori assoluti si deducono facilmente dalla definizione; per gli
errori relativi abbiamo usato il fatto che <span class="math notranslate nohighlight">\(|x|&gt; b^{\eta-1}\)</span>.</p>
<p>La quantità <span class="math notranslate nohighlight">\(u:=\frac12 b^{1-t}\)</span> è detta <em>unit roundoff</em>, mentre
<span class="math notranslate nohighlight">\(b^{1-t}\)</span> è l”<em>epsilon di macchina</em> [&#64;higham]. In MATLAB il comando
<code class="docutils literal notranslate"><span class="pre">eps</span></code> restituisce il valore dell’epsilon di macchina per il formato in
doppia precisione, cioè <span class="math notranslate nohighlight">\(2^{-52}\approx 2.22\cdot 10^{-16}\)</span>.</p>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="aritmetica-di-macchina">
<h1>Aritmetica di macchina<a class="headerlink" href="#aritmetica-di-macchina" title="Link a questa intestazione">#</a></h1>
<p>Osserviamo che l’insieme <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> non è chiuso rispetto alle
quattro operazioni aritmetiche: la somma (o la differenza, il prodotto,
il quoziente) esatta di due numeri di macchina potrebbe non essere un
numero di macchina. È quindi necessario definire un’aritmetica di
macchina, ovvero delle operazioni binarie <span class="math notranslate nohighlight">\(\oplus,\ominus,\otimes,\oslash\)</span>,
su <span class="math notranslate nohighlight">\(\mathcal{F}\)</span> in modo tale che si abbia</p>
<div class="math notranslate nohighlight">
\[\require{enclose}
x \enclose{circle}{\text{op}} y = (1+\varepsilon) (x\, {\rm op}\, y),\qquad |\varepsilon|&lt; u\]</div>
<p>per</p>
<div class="math notranslate nohighlight">
\[
\require{enclose}
\enclose{circle}{\text{op}}= +,-,\times,/.
\]</div>
<div class="admonition warning">
<p class="admonition-title">Avvertimento</p>
<p>L’espressione «floating-point operation» (operazione di macchina) è
spesso abbreviata in <em>flop</em>, in particolare quando si stima il costo
computazionale di un algoritmo contando il numero di operazioni
richieste.</p>
<p>Le operazioni di macchina non sempre rispettano le proprietà delle
operazioni classiche, come l’associatività o la distributività. Per
esempio, l’addizione non è necessariamente associativa. Consideriamo in
<span class="math notranslate nohighlight">\(\mathcal{F}_{10,2,4,4}\)</span> i numeri</p>
<div class="math notranslate nohighlight">
\[
x=0.11\times 10^{0},\qquad
y=0.13\times 10^{-1},\qquad
z=0.14\times 10^{-1}\]</div>
<p>e supponiamo che l’addizione di macchina sia
definita da <span class="math notranslate nohighlight">\(a\oplus b={\rm arr}(a+b)\)</span>. Allora si ha</p>
<div class="math notranslate nohighlight">
\[
(x\oplus y)\oplus z = 0.12\times 10^0\oplus 0.14\times 10^{-1} = 0.13\times 10^0\]</div>
<p>e</p>
<div class="math notranslate nohighlight">
\[
x\oplus (y\oplus z) = 0.11\times 10^0\oplus 0.27\times 10^{-1} = 0.14\times 10^0.\]</div>
</div>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="valutazione-di-una-funzione-analisi-dell-errore">
<h1>Valutazione di una funzione: analisi dell’errore<a class="headerlink" href="#valutazione-di-una-funzione-analisi-dell-errore" title="Link a questa intestazione">#</a></h1>
<p>Data una funzione</p>
<div class="math notranslate nohighlight">
\[
f:D\subset\mathbb{R}^n\longrightarrow\mathbb{R}\]</div>
<p>e
fissato <span class="math notranslate nohighlight">\(x\in\mathbb{R}^n\)</span>, supponiamo di voler approssimare <span class="math notranslate nohighlight">\(f(x)\)</span>
numericamente.</p>
<p>Sia <span class="math notranslate nohighlight">\(\tilde{x}\)</span> la rappresentazione di <span class="math notranslate nohighlight">\(x\)</span> in numeri di macchina. Poiché
abbiamo a disposizione solo le quattro operazioni, la funzione <span class="math notranslate nohighlight">\(f\)</span> dovrà
essere approssimata da un’opportuna funzione razionale <span class="math notranslate nohighlight">\(g\)</span>. L’uso delle
operazioni di macchina, poi, fa sı̀ che la funzione effettivamente
calcolata in aritmetica di macchina non sia <span class="math notranslate nohighlight">\(g\)</span>, ma un’altra funzione
che chiameremo <span class="math notranslate nohighlight">\(\psi\)</span>.</p>
<p>Avremo quindi i seguenti errori:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\varepsilon\)</span> tale che <span class="math notranslate nohighlight">\(\tilde{x}=x(1+\varepsilon)\)</span> e
<span class="math notranslate nohighlight">\(\|\varepsilon\|&lt;u\)</span> <em>(errore di rappresentazione o roundoff)</em>,</p></li>
<li><p><span class="math notranslate nohighlight">\(E_{\rm an}=\frac{f(x)-g(x)}{f(x)}\)</span> <em>(errore analitico),</em></p></li>
<li><p><span class="math notranslate nohighlight">\(E_{\rm alg}=\frac{g(\tilde{x})-\psi(\tilde{x})}{g(\tilde{x})}\)</span>
<em>(errore algoritmico),</em></p></li>
<li><p><span class="math notranslate nohighlight">\(E_{\rm in}=\frac{g(x)-g(\tilde{x})}{g(x)}\)</span> <em>(errore inerente),</em></p></li>
<li><p><span class="math notranslate nohighlight">\(E_{\rm tot}=\frac{f(x)-\psi(\tilde{x})}{f(x)}\)</span> <em>(errore totale),</em></p></li>
</ul>
<p>dove naturalmente si suppone che i denominatori siano diversi da zero.</p>
<p>Per esempio, supponiamo di voler valutare <span class="math notranslate nohighlight">\(f(x)=e^x\)</span> per un dato
<span class="math notranslate nohighlight">\(x\in\mathbb{R}\)</span>. Scegliamo come approssimazione razionale
dell’esponenziale la serie di Taylor troncata all’ordine 3, cioè</p>
<div class="math notranslate nohighlight">
\[
g(x)=1+x+\frac{x^2}{2}+\frac{x^3}{6}.\]</div>
<p>L’errore analitico è allora</p>
<div class="math notranslate nohighlight">
\[
E_{\rm an}=\frac{e^x-(1+x+x^2/2+x^3/6)}{e^x}.\]</div>
<p>In pratica però non
valuto <span class="math notranslate nohighlight">\(g(x)\)</span>, bensı̀ <span class="math notranslate nohighlight">\(g(\tilde{x})\)</span>, da cui l’errore inerente
<span class="math notranslate nohighlight">\(E_{\rm in}=(g(x)-g(\tilde{x}))/g(x)\)</span>. L’implementazione del calcolo di
<span class="math notranslate nohighlight">\(g(\tilde{x})\)</span> tramite le operazioni di macchina dà luogo a</p>
<div class="math notranslate nohighlight">
\[
\psi(\tilde{x})=\tilde{1}\oplus\tilde{x}\oplus(\tilde{x}\otimes\tilde{x})\oslash\tilde{2}\oplus((\tilde{x}\otimes\tilde{x})\otimes\tilde{x})\oslash\tilde{6}\]</div>
<p>che in generale sarà una quantità diversa da
<span class="math notranslate nohighlight">\(g(\tilde{x})\)</span>, perciò si ha l’errore algoritmico
<span class="math notranslate nohighlight">\(E_{\rm alg}=(g(\tilde{x})-\psi(\tilde{x}))g(\tilde{x})\)</span>. Osserviamo
però che avremmo anche potuto scegliere di scrivere <span class="math notranslate nohighlight">\(\psi\)</span> in modo
diverso, per esempio</p>
<div class="math notranslate nohighlight">
\[
1+x+x(1/2+x/6)\]</div>
<p>e avremmo ottenuto un errore
algoritmico ancora diverso.</p>
<p>Ci chiediamo come l’errore totale dipenda dagli altri errori. Si ha</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
&amp;E_{\rm tot}&amp;=1-\frac{\psi(\tilde{x})}{f(x)}\\
&amp;&amp; = 1-\frac{\psi(\tilde{x})}{g(\tilde{x})}\cdot
\frac{g(\tilde{x})}{g(x)}\cdot\frac{g(x)}{f(x)}\\
&amp;&amp; = 1-(1-E_{\rm alg})(1-E_{\rm in})(1-E_{\rm an})\\
&amp;&amp; \simeq E_{\rm alg}+E_{\rm in}+E_{\rm an},\end{aligned}\end{split}\]</div>
<p>dove
l’ultima uguaglianza è intesa al primo ordine.</p>
<p>Supponiamo ora che <span class="math notranslate nohighlight">\(f\)</span> sia razionale, quindi l’errore analitico è nullo.
Sviluppo <span class="math notranslate nohighlight">\(f\)</span> in serie di Taylor al primo ordine:</p>
<div class="math notranslate nohighlight">
\[
f(\tilde{x})\simeq f(x)+\sum_{i=1}^n
\frac{\partial f}{\partial x_i}(x)(\tilde{x}_i-x_i)\]</div>
<p>e indico con
<span class="math notranslate nohighlight">\(x_i\)</span>, <span class="math notranslate nohighlight">\(\tilde{x}_i\)</span>, <span class="math notranslate nohighlight">\(\varepsilon_i\)</span> le componenti di vettori
<span class="math notranslate nohighlight">\(x,\tilde{x},\varepsilon\in\mathbb{R}^n\)</span>, rispettivamente. Al primo
ordine si ha</p>
<div class="math notranslate nohighlight">
\[
f(\tilde{x}-f(x))\simeq\sum_{i=1}^n
\frac{\partial f}{\partial x_i}(x)(\tilde{x}_i-x_i)
\simeq \sum_{i=1}^n\varepsilon_i x_i\frac{\partial f}{\partial x_i}(x).\]</div>
<p>L’errore inerente è</p>
<div class="math notranslate nohighlight">
\[
-E_{\rm in}\simeq\sum_{i=1}^n\varepsilon_i
\frac{x_i}{f(x)}\frac{\partial f}{\partial x_i}(x)
=\sum_{i=1}^n\varepsilon_i\gamma_i,\]</div>
<p>dove i <em>coefficienti di
amplificazione</em> <span class="math notranslate nohighlight">\(\gamma_i\)</span> sono definiti come
<span class="math notranslate nohighlight">\(\gamma_i=\frac{x_i}{f(x)}\frac{\partial f}{\partial x_i}(x)\)</span> per
<span class="math notranslate nohighlight">\(i=1,\ldots,n\)</span>.</p>
<p>Se i <span class="math notranslate nohighlight">\(\gamma_i\)</span> sono piccoli in valore assoluto, allora gli errori di
roundoff su <span class="math notranslate nohighlight">\(x\)</span> non vengono amplificati. Invece se i <span class="math notranslate nohighlight">\(|\gamma_i|\)</span> sono
grandi potrebbe verificarsi un’amplificazione dell’errore inerente, cioè
si avrebbe un <em>problema mal condizionato</em>.</p>
<p>Osserviamo che la discussione dell’errore inerente (e quindi del
condizionamento) non dipende dall’algoritmo scelto per approssimare
<span class="math notranslate nohighlight">\(f(x)\)</span>, ma solo dal problema, ovvero da <span class="math notranslate nohighlight">\(f\)</span> e da <span class="math notranslate nohighlight">\(x\)</span>.</p>
<p>La crescita dell’errore inerente è legata al <em>condizionamento</em> del
problema; la crescita dell’errore algoritmico dipende invece dalla
<em>stabilità</em> dell’algoritmo scelto.</p>
<section id="condizionamento-delle-operazioni-di-macchina">
<h2>Condizionamento delle operazioni di macchina<a class="headerlink" href="#condizionamento-delle-operazioni-di-macchina" title="Link a questa intestazione">#</a></h2>
<p>Come esempio della discussione precedente studiamo il condizionamento
delle operazioni di macchina. Si tratta quindi di valutare l’errore
inerente per ciascuna operazione e di calcolare i coefficienti di
amplificazione <span class="math notranslate nohighlight">\(\gamma_i\)</span>.</p>
<p><strong>Addizione.</strong> Supponiamo di voler calcolare <span class="math notranslate nohighlight">\(x_1+x_2\)</span>. Avremo</p>
<div class="math notranslate nohighlight">
\[
\tilde{x}_1=(1+\varepsilon_1)x_1,\qquad
\tilde{x}_2=(1+\varepsilon_2)x_2,\]</div>
<p>con <span class="math notranslate nohighlight">\(|\varepsilon_1|&lt;u\)</span>,
<span class="math notranslate nohighlight">\(|\varepsilon_2|&lt;u\)</span>, e</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E_{\rm in}&amp;=&amp;\frac{(\tilde{x}_1+\tilde{x}_2)-(x_1+x_2)}{x_1+x_2}=\\
&amp;&amp;=\frac{(1+\varepsilon_1)x_1+(1+\varepsilon_2)x_2 -x_1-x_2}{x_1+x_2}=\\
&amp;&amp;=\frac{\varepsilon_1 x_1+\varepsilon_2 x_2}{x_1+x_2}=
\varepsilon_1\frac{x_1}{x_1+x_2}+\varepsilon_2\frac{x_2}{x_1+x_2}.\end{aligned}\end{split}\]</div>
<p>Nell’espressione trovata per <span class="math notranslate nohighlight">\(E_{\rm in}\)</span>, i coefficienti di
amplificazione sono <span class="math notranslate nohighlight">\(\gamma_1=x_1/(x_1+x_2)\)</span> e <span class="math notranslate nohighlight">\(\gamma_2=x_2/(x_1+x_2)\)</span>.
Osserviamo che, se <span class="math notranslate nohighlight">\(x_1\)</span> e <span class="math notranslate nohighlight">\(x_2\)</span> hanno segno opposto e
<span class="math notranslate nohighlight">\(|x_1|\simeq |x_2|\)</span>, allora <span class="math notranslate nohighlight">\(\gamma_1\)</span> e <span class="math notranslate nohighlight">\(\gamma_2\)</span> sono grandi e
l’operazione di addizione è mal condizionata (fenomeno della
<em>cancellazione</em> numerica).</p>
<p><strong>Sottrazione.</strong> Si ha</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E_{\rm in}&amp;=&amp;\frac{(\tilde{x}_1-\tilde{x}_2)-(x_1-x_2)}{x_1-x_2}=\\
&amp;&amp;=\frac{(1+\varepsilon_1)x_1-(1+\varepsilon_2)x_2 -x_1+x_2}{x_1-x_2}=\\
&amp;&amp;=\frac{\varepsilon_1 x_1+\varepsilon_2 x_2}{x_1+x_2}=
\varepsilon_1\frac{x_1}{x_1-x_2}+\varepsilon_2\frac{-x_2}{x_1-x_2}.\end{aligned}\end{split}\]</div>
<p>I coefficienti di amplificazione sono <span class="math notranslate nohighlight">\(\gamma_1=x_1/(x_1-x_2)\)</span> e
<span class="math notranslate nohighlight">\(\gamma_2=-x_2/(x_1-x_2)\)</span>. Si ha cancellazione, e quindi
malcondizionamento, se <span class="math notranslate nohighlight">\(x_1\sim x_2\)</span>.</p>
<p><strong>Moltiplicazione.</strong> Si ha</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E_{\rm in}&amp;=&amp;\frac{\tilde{x}_1\tilde{x}_2-x_1x_2}{x_1x_2}=\\
&amp;&amp;=\frac{(1+\varepsilon_1)x_1(1+\varepsilon_2)x_2 -x_1x_2}{x_1x_2}=\\
&amp;&amp;=\frac{\varepsilon_1 x_1 x_2+\varepsilon_2 x_1 x_2}{x_1x_2}=
\varepsilon_1+\varepsilon_2.\end{aligned}\end{split}\]</div>
<p>I coefficienti di
amplificazione sono <span class="math notranslate nohighlight">\(\gamma_1=\gamma_2=1\)</span>, quindi la moltiplicazione è
sempre ben condizionata.</p>
<p><strong>Divisione.</strong> Supponiamo che i denominatori che useremo siano diversi
da 0. Si ha</p>
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{aligned}
E_{\rm in}&amp;=&amp;\frac{\tilde{x}_1/\tilde{x}_2-x_1/x_2}{x_1/x_2}=\\
&amp;&amp;=\frac{(1+\varepsilon_1)x_1/(1+\varepsilon_2)x_2 -x_1/x_2}{x_1/x_2}=\\
&amp;&amp;=\frac{1+\varepsilon_1 -1- \varepsilon_2}{1+\varepsilon_2}\simeq
\varepsilon_1-\varepsilon_2.\end{aligned}\end{split}\]</div>
<p>Concludiamo che anche la
divisione è sempre ben condizionata.</p>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="referenze">
<h1>Referenze<a class="headerlink" href="#referenze" title="Link a questa intestazione">#</a></h1>
<ul class="simple">
<li><p>D. Bini, M. Capovani, O. Menchi, <em>Metodi numerici per l’algebra
lineare</em>, Zanichelli 1988. R. Bevilacqua, D. Bini, M. Capovani,</p></li>
<li><p>O. Menchi, <em>Metodi numerici</em>, Zanichelli 1992.</p></li>
<li><p>D. Goldberg, <em>What every
computer scientist should know about floating-point arithmetic.</em> ACM
computing surveys (CSUR) 23.1 (1991): 5-48.</p></li>
<li><p>Nicholas J. Higham,
<em>Accuracy and Stability of Numerical Algorithms</em>, second edition,
Society for Industrial and Applied Mathematics, Philadelphia, PA, USA, 2002.</p></li>
<li><p>IEEE Standard for Floating-Point Arithmetic, IEEE Std 754-2019
(Revision of IEEE 754-2008), The Institute of Electrical and Electronics
Engineers, New York, 2019.</p></li>
</ul>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./."
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="laboratorio1.html" title="precedente pagina">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">precedente</p>
            <p class="prev-next-title">Laboratorio 1 : Introduzione a MATLAB</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="laboratorio2.html" title="successivo pagina">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">successivo</p>
        <p class="prev-next-title">Laboratorio 2 : L’Aritmetica di Precisione Finita</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By P. Boito, F. Durastante<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>